.. em_analysis:

Processing Cryo-EM Electron Density Map
==================================================================

Lets start with essential import statements:

.. ipython:: python

   from prody import *
   import numpy as np
   import matplotlib


Parse Density Map
-----------------------------------------------------------------

The first step is to parse a .map file, which contains information
about a density map as the electron density at points on a grid.
This file format is a binary format also known as CCP4 or MRC2014. 

.. ipython:: python

   emd = parseEMD('EMD-1961.map', cutoff=1.2, n_nodes=3000, num_iter=30)
   emd

This function returns an atom group from the electron density
map. The cutoff parameter discards any electron density lower than
the given number, n_nodes is the parameter that describes the
total number of beads that initialize the system. The method to
build coordinates is also called the "Topology Representing
Network" algorithm, which is an iterative algorithm and num_iter 
is therefore a required parameter for this algorithm. 
The resultant structure is given in the following figure. 

Note: Depending on your hardware, this may take a while - around
30 minutes. To skip this step, you can load the structure file
directly in PDB format (EMD-1961.pdb).

.. figure:: ../../_static/figures/8000nodes_with_map.png
   :scale: 80%


The 144x144x144 density grid is converted into an :class:`.AtomGroup`
class and elastic network model analysis can be applied to the 
constructed structure as usual. 


Map pseudo-atoms to PDB atomic model
-----------------------------------------------------------------

To save time, we parse pseudo-atoms from a PDB file with a previously 
reconstructed model:

.. ipython:: python

   emd = parsePDB('EMD-1961.pdb')
   pdb = parsePDB('4a0v.pdb', subset='ca')

The order of pseudo-atoms generated by TRN is random and does not follow a sequence like 
residues in an atomic model do. Also, they have no chain identifiers. For the purpose of 
visualization and later comparative analyses, we reorder the pseudo-atoms and assign the 
chain identifers to the pseudo-atoms based on the PDB structure in the following section. 


Unique one-to-one mapping of pseudo-atoms to an atomic model is nontrivial, 
since there is no correspondence between the beads and the residues of the 
protein. For simplicity, here we use the k-nearest neighbors algorithm to 
find 20 closest residues in the atomic model to a given pseudo-atom. Then 
we create a one-to-one mapping by assigning the closest residue, or the 
next closest if it is already assigned, to a pseudo-atom. Note that this 
is by no means the optimal one-to-one mapping, and for more complicated methods 
which guarantees the optimal mapping, see for example the "stable marriage problem".

.. ipython:: python

   from sklearn.neighbors import NearestNeighbors
   mapping = []
   nbrs = NearestNeighbors(n_neighbors=20, algorithm='ball_tree').fit(pdb.getCoords())
   _, indices = nbrs.kneighbors(emd.getCoords())
   for neighbors in indices:
      for i in neighbors: 
         if i not in mapping:
            mapping.append(i)
            break
            
   indices = np.array(mapping)
   I = np.argsort(indices)

Note that ``indices`` returned from :class:`~sklearn.NearestNeighbors` is a 2-D array with 
rows corresponding to pseudo-atoms and columns their k-neighbors. After being processed by the 
for-loop above, each element of ``indices`` is the index of the residue in the atomic model 
that should be assigned to the pseudo-atom. Then, :func:`~numpy.argsort` is applied to obtain 
indices for reordering the pseudo-atoms following the order of the atoms (residues) in the 
atomic model. 

We first create a :class:`AtomMap` for the atomic model with only the residues that were mapped 
to a pseudo-atom.

.. ipython:: python

   pmap = AtomMap(pdb, indices[I])

Then we create a new :class:`AtomGroup` for the pseudo-atoms based on the mapping, such that 
they are ordered according to the sequence of residues they are assigned to:

.. ipython:: python

   emd2 = AtomMap(emd, I).toAtomGroup()
   resnums = pmap.getResnums()
   emd2.setResnums(resnums)

   chids = pmap.getChids()
   emd2.setChids(chids)


Now we can calculate the RMSD between the pseudo-atoms and their mapped residues in the 
atomic model:

.. ipython:: python

   calcRMSD(emd2, pmap)


Finally, we save the ordered pseudo-atom model to a PDB file for visualization and other 
downstream analyses:

.. ipython:: python

   writePDB('EMD-1961_mapped.pdb', emd2)


Elastic Network Model Analysis
==================================================================

Elastic network model analysis can be applied to the pseudo-atomic model as usual, 
with or without the reordering discussed above:

.. ipython:: python
   :verbatim:
   
   anm_emd = ANM('TRiC EMDMAP ANM Analysis')
   anm_emd.buildHessian(emd2, cutoff=20)
   anm_emd.calcModes(n_modes=5)
   writeNMD('tric_anm_3_modes_3000nodes.nmd', anm_emd[:3], emd2)


Compare results with atomic models
-----------------------------------------------------------------

For comparison, let's perform ENM analysis for the atomic model (i.e. ``pmap`` we 
created earlier) as well, and apply the reduced model to it by treating residues 
that are not assigned to a pseudo-atom as the environment.

.. ipython:: python

   anm_pdb = ANM('4a0v ANM')

   anm_pdb.buildHessian(pdb)
   anm_pdb_reduced, _ = reduceModel(anm_pdb, pdb, pmap)

   anm_pdb_reduced.calcModes(n_modes=5)

Now we compare modes of the pseudo-atomic model to the atomic model:

.. ipython:: python

   @savefig cryody_anm_overlap.png width=4in
   showOverlapTable(anm_emd, anm_pdb_reduced)
